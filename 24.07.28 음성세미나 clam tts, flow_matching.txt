clam tts

제로샷을 활용해서 tts 생성
인코덱 - 오디오, 스피치를 코드북으로 만들고 예측 가능해짐
오디오 토큰을 순차적으로 생성해서 오래걸림

- mel vae, 레이턴트 랭귀지 모델을 활용해서 해결

다양한 부분에서 우수하거나 비슷함 - 개선 비용이 줄고, 추론 속도가 빨라짐

mel-vae의 생성

continuous latent audio representation - 한번에 모든 토큰을 뽑을 수 있음

제안 방법
	- 제로샷 tts 모델 구현
		- 입력 데이터 x, 스피치 데이터의 멜스펙트로그램 활용

데이터 표현 방법
	- mean field variation으로 mel vae 구현

큰 표현부터 시작해서 각 필드마다 점점 세세한 부분을 학습시킴


각 절차(depth)에 따라 각 코드북에 대해 나눈 후에, 근사하게 훈련시킴(?)

mixture weight, gaussian mixture sitribution의 평균 활용
	- 병렬적인 값을 활용해서 샘플링으로 활용하게 됨

트랜스포머 디코더 + 3가지 병렬 모듈로 생성


실험
	- 10만 시간, 12000명의 화자, 언어는 11종류로 진행


멜 인코더 - 레프레젠테이션만 압축

제로샷 - 코덱 계열로 많이 사용함, 코덱이 특히 어느 장점을 가지고 있나?
	코덱은 많은 데이터로 학습되어 있음, 특징 발화스타일등이 잘 반영이 되어있다고 판단됨
 	랭귀지 모델에 얼마나 많은 데이터, 얼마나 정제된 데이터가 있는지에 따라 달라짐
	성능은 랭귀지 모델, 사용하려면 코덱이 필요함



플로우 매칭
기본용어
	- probability density path
		t가 변함에 따라 분포의 모양(평균, 표준편차)이 바뀌어도, 총합은 유지됨
	- flow
		diffeomorphic 미분 가능하고 ??
	- 벡터 필드
		t 시점에서의 xt의 위치 결정 확인, 이동방향 확인가능
	- continuity equation
		일종의 보존법칙, 시간의 흐름에 따라 달라짐	
		유입량과 유출량이 동일함
	- probability density path는 벡터 필드에 따라 형성되므로, 벡터 필드를 잘 만들어야 함
		t는 0에서 1로 넘어가는데, 자연스럽게 이렇게 쓰는 경우가 많았음(t=0은 가우시안에가깝고, 1은 실제 데이터임)

플로우 매칭
	- 노멀라이징 플로우가 discrete에서 continuous로 발전함
	neural ode - 학습 과정이 느려짐

특정 시점에서의 벡터를 regression으로 학습시키는 방식 선택
로스에서 타겟 벡터를 계산할 수 있어야 함 - 샘플 하나에는 접근 가능(계산량 부담 가능)

conditional flow matching
	- 얻고 싶은 x에 대한 데이터는 x1에서 마지널라이제이션
??

미분을 통해서 계산(?)

t=0에서 시작해서 t=1인 실제 데이터와 유사한 형태를 지닌 벡터 필드들이 생성됨
타겟을 가장 간단한 벡터 필드로 변경 - affine transform으로 구성시킴


최적 변환 경로
	- optimal transport theroy - 평균과 분산히 선형적으로 변화하는 경로가 최적임
		t에 맞춰서 선형적으로 이동하는 평균과 분산이 가장 적당함




